<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures in C++</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 2.5em;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            margin-top: 10px;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 24px;
            background: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .tab.active {
            background: #3498db;
            color: white;
        }

        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .content.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-top: 0;
        }

        h3 {
            color: #2980b9;
            margin-top: 25px;
        }

        .question {
            background: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            float: right;
            transition: background 0.3s;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .structure {
            background: #e8f4fc;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #2980b9;
        }

        .operation {
            background: #d4edda;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #28a745;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: #666;
            padding: 20px;
            border-top: 1px solid #ddd;
        }

        .index {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .index-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .index-num {
            display: inline-block;
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            text-align: center;
            line-height: 30px;
            border-radius: 50%;
            margin-right: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: #3498db;
            color: white;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        .complexity {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
    </style>
</head>

<body>
    <a href="python.html">python ->>>>></a>
    <br><br>
    <a href="index.html">Web deisgn ->>>>></a>
    <br><br>
    <div class="header">
        <h1>Data Structures Implementation in C++</h1>
        <div class="subtitle">Complete C++ implementations of Linked Lists, Stacks, and Queues</div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="showTab('linkedLists')">Linked Lists</button>
        <button class="tab" onclick="showTab('stacks')">Stacks</button>
        <button class="tab" onclick="showTab('queues')">Queues</button>
    </div>

    <!-- Linked Lists Content -->
    <div id="linkedLists" class="content active">
        <h2>Linked Lists Implementation in C++</h2>

        <div class="question">
            <h3>1. Singly Linked List</h3>
            <button class="copy-btn" onclick="copyCode('code1')">Copy Code</button>
            <pre id="code1">#include <iostream>
using namespace std;

// Node structure for Singly Linked List
struct Node {
    int data;
    Node* next;
    
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// Singly Linked List class
class SinglyLinkedList {
private:
    Node* head;
    
public:
    SinglyLinkedList() {
        head = nullptr;
    }
    
    // Insert at beginning
    void insertAtBeginning(int val) {
        Node* newNode = new Node(val);
        newNode->next = head;
        head = newNode;
        cout << val << " inserted at beginning.\n";
    }
    
    // Insert at end
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
        cout << val << " inserted at end.\n";
    }
    
    // Insert at position
    void insertAtPosition(int val, int pos) {
        if (pos < 1) {
            cout << "Invalid position!\n";
            return;
        }
        
        if (pos == 1) {
            insertAtBeginning(val);
            return;
        }
        
        Node* newNode = new Node(val);
        Node* temp = head;
        
        for (int i = 1; i < pos - 1 && temp != nullptr; i++) {
            temp = temp->next;
        }
        
        if (temp == nullptr) {
            cout << "Position out of bounds!\n";
            delete newNode;
        } else {
            newNode->next = temp->next;
            temp->next = newNode;
            cout << val << " inserted at position " << pos << ".\n";
        }
    }
    
    // Delete from beginning
    void deleteFromBeginning() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        Node* temp = head;
        head = head->next;
        cout << temp->data << " deleted from beginning.\n";
        delete temp;
    }
    
    // Delete from end
    void deleteFromEnd() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        if (head->next == nullptr) {
            cout << head->data << " deleted from end.\n";
            delete head;
            head = nullptr;
            return;
        }
        
        Node* temp = head;
        while (temp->next->next != nullptr) {
            temp = temp->next;
        }
        
        cout << temp->next->data << " deleted from end.\n";
        delete temp->next;
        temp->next = nullptr;
    }
    
    // Delete from position
    void deleteFromPosition(int pos) {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        if (pos < 1) {
            cout << "Invalid position!\n";
            return;
        }
        
        if (pos == 1) {
            deleteFromBeginning();
            return;
        }
        
        Node* temp = head;
        for (int i = 1; i < pos - 1 && temp != nullptr; i++) {
            temp = temp->next;
        }
        
        if (temp == nullptr || temp->next == nullptr) {
            cout << "Position out of bounds!\n";
            return;
        }
        
        Node* toDelete = temp->next;
        temp->next = temp->next->next;
        cout << toDelete->data << " deleted from position " << pos << ".\n";
        delete toDelete;
    }
    
    // Search element
    bool search(int val) {
        Node* temp = head;
        int position = 1;
        
        while (temp != nullptr) {
            if (temp->data == val) {
                cout << val << " found at position " << position << ".\n";
                return true;
            }
            temp = temp->next;
            position++;
        }
        
        cout << val << " not found in list.\n";
        return false;
    }
    
    // Display list
    void display() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        Node* temp = head;
        cout << "Singly Linked List: ";
        while (temp != nullptr) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
    
    // Get length
    int length() {
        int count = 0;
        Node* temp = head;
        
        while (temp != nullptr) {
            count++;
            temp = temp->next;
        }
        
        return count;
    }
    
    // Reverse list
    void reverse() {
        Node* prev = nullptr;
        Node* current = head;
        Node* next = nullptr;
        
        while (current != nullptr) {
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        
        head = prev;
        cout << "List reversed.\n";
    }
    
    // Destructor
    ~SinglyLinkedList() {
        Node* temp;
        while (head != nullptr) {
            temp = head;
            head = head->next;
            delete temp;
        }
    }
};

// Main function to test Singly Linked List
int main() {
    SinglyLinkedList sll;
    int choice, value, position;
    
    do {
        cout << "\n===== Singly Linked List Menu =====" << endl;
        cout << "1. Insert at beginning" << endl;
        cout << "2. Insert at end" << endl;
        cout << "3. Insert at position" << endl;
        cout << "4. Delete from beginning" << endl;
        cout << "5. Delete from end" << endl;
        cout << "6. Delete from position" << endl;
        cout << "7. Search element" << endl;
        cout << "8. Display list" << endl;
        cout << "9. Get length" << endl;
        cout << "10. Reverse list" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                sll.insertAtBeginning(value);
                break;
                
            case 2:
                cout << "Enter value to insert: ";
                cin >> value;
                sll.insertAtEnd(value);
                break;
                
            case 3:
                cout << "Enter value to insert: ";
                cin >> value;
                cout << "Enter position: ";
                cin >> position;
                sll.insertAtPosition(value, position);
                break;
                
            case 4:
                sll.deleteFromBeginning();
                break;
                
            case 5:
                sll.deleteFromEnd();
                break;
                
            case 6:
                cout << "Enter position to delete: ";
                cin >> position;
                sll.deleteFromPosition(position);
                break;
                
            case 7:
                cout << "Enter value to search: ";
                cin >> value;
                sll.search(value);
                break;
                
            case 8:
                sll.display();
                break;
                
            case 9:
                cout << "Length of list: " << sll.length() << endl;
                break;
                
            case 10:
                sll.reverse();
                break;
                
            case 0:
                cout << "Exiting program.\n";
                break;
                
            default:
                cout << "Invalid choice!\n";
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>2. Doubly Linked List</h3>
            <button class="copy-btn" onclick="copyCode('code2')">Copy Code</button>
            <pre id="code2">#include <iostream>
using namespace std;

// Node structure for Doubly Linked List
struct DNode {
    int data;
    DNode* prev;
    DNode* next;
    
    DNode(int val) {
        data = val;
        prev = nullptr;
        next = nullptr;
    }
};

// Doubly Linked List class
class DoublyLinkedList {
private:
    DNode* head;
    DNode* tail;
    
public:
    DoublyLinkedList() {
        head = nullptr;
        tail = nullptr;
    }
    
    // Insert at beginning
    void insertAtBeginning(int val) {
        DNode* newNode = new DNode(val);
        
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
        cout << val << " inserted at beginning.\n";
    }
    
    // Insert at end
    void insertAtEnd(int val) {
        DNode* newNode = new DNode(val);
        
        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            newNode->prev = tail;
            tail->next = newNode;
            tail = newNode;
        }
        cout << val << " inserted at end.\n";
    }
    
    // Insert at position
    void insertAtPosition(int val, int pos) {
        if (pos < 1) {
            cout << "Invalid position!\n";
            return;
        }
        
        if (pos == 1) {
            insertAtBeginning(val);
            return;
        }
        
        DNode* newNode = new DNode(val);
        DNode* temp = head;
        
        for (int i = 1; i < pos - 1 && temp != nullptr; i++) {
            temp = temp->next;
        }
        
        if (temp == nullptr) {
            cout << "Position out of bounds!\n";
            delete newNode;
        } else {
            newNode->next = temp->next;
            newNode->prev = temp;
            
            if (temp->next != nullptr) {
                temp->next->prev = newNode;
            } else {
                tail = newNode;
            }
            
            temp->next = newNode;
            cout << val << " inserted at position " << pos << ".\n";
        }
    }
    
    // Delete from beginning
    void deleteFromBeginning() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        DNode* temp = head;
        
        if (head == tail) {
            head = tail = nullptr;
        } else {
            head = head->next;
            head->prev = nullptr;
        }
        
        cout << temp->data << " deleted from beginning.\n";
        delete temp;
    }
    
    // Delete from end
    void deleteFromEnd() {
        if (tail == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        DNode* temp = tail;
        
        if (head == tail) {
            head = tail = nullptr;
        } else {
            tail = tail->prev;
            tail->next = nullptr;
        }
        
        cout << temp->data << " deleted from end.\n";
        delete temp;
    }
    
    // Delete from position
    void deleteFromPosition(int pos) {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        if (pos < 1) {
            cout << "Invalid position!\n";
            return;
        }
        
        if (pos == 1) {
            deleteFromBeginning();
            return;
        }
        
        DNode* temp = head;
        for (int i = 1; i < pos && temp != nullptr; i++) {
            temp = temp->next;
        }
        
        if (temp == nullptr) {
            cout << "Position out of bounds!\n";
            return;
        }
        
        if (temp == tail) {
            deleteFromEnd();
            return;
        }
        
        temp->prev->next = temp->next;
        temp->next->prev = temp->prev;
        
        cout << temp->data << " deleted from position " << pos << ".\n";
        delete temp;
    }
    
    // Display forward
    void displayForward() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        DNode* temp = head;
        cout << "Doubly Linked List (Forward): ";
        while (temp != nullptr) {
            cout << temp->data << " <-> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
    
    // Display backward
    void displayBackward() {
        if (tail == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        DNode* temp = tail;
        cout << "Doubly Linked List (Backward): ";
        while (temp != nullptr) {
            cout << temp->data << " <-> ";
            temp = temp->prev;
        }
        cout << "NULL\n";
    }
    
    // Search element
    bool search(int val) {
        DNode* temp = head;
        int position = 1;
        
        while (temp != nullptr) {
            if (temp->data == val) {
                cout << val << " found at position " << position << ".\n";
                return true;
            }
            temp = temp->next;
            position++;
        }
        
        cout << val << " not found in list.\n";
        return false;
    }
    
    // Get length
    int length() {
        int count = 0;
        DNode* temp = head;
        
        while (temp != nullptr) {
            count++;
            temp = temp->next;
        }
        
        return count;
    }
    
    // Destructor
    ~DoublyLinkedList() {
        DNode* temp;
        while (head != nullptr) {
            temp = head;
            head = head->next;
            delete temp;
        }
    }
};

// Main function to test Doubly Linked List
int main() {
    DoublyLinkedList dll;
    int choice, value, position;
    
    do {
        cout << "\n===== Doubly Linked List Menu =====" << endl;
        cout << "1. Insert at beginning" << endl;
        cout << "2. Insert at end" << endl;
        cout << "3. Insert at position" << endl;
        cout << "4. Delete from beginning" << endl;
        cout << "5. Delete from end" << endl;
        cout << "6. Delete from position" << endl;
        cout << "7. Search element" << endl;
        cout << "8. Display forward" << endl;
        cout << "9. Display backward" << endl;
        cout << "10. Get length" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                dll.insertAtBeginning(value);
                break;
                
            case 2:
                cout << "Enter value to insert: ";
                cin >> value;
                dll.insertAtEnd(value);
                break;
                
            case 3:
                cout << "Enter value to insert: ";
                cin >> value;
                cout << "Enter position: ";
                cin >> position;
                dll.insertAtPosition(value, position);
                break;
                
            case 4:
                dll.deleteFromBeginning();
                break;
                
            case 5:
                dll.deleteFromEnd();
                break;
                
            case 6:
                cout << "Enter position to delete: ";
                cin >> position;
                dll.deleteFromPosition(position);
                break;
                
            case 7:
                cout << "Enter value to search: ";
                cin >> value;
                dll.search(value);
                break;
                
            case 8:
                dll.displayForward();
                break;
                
            case 9:
                dll.displayBackward();
                break;
                
            case 10:
                cout << "Length of list: " << dll.length() << endl;
                break;
                
            case 0:
                cout << "Exiting program.\n";
                break;
                
            default:
                cout << "Invalid choice!\n";
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>3. Circular Linked List</h3>
            <button class="copy-btn" onclick="copyCode('code3')">Copy Code</button>
            <pre id="code3">#include <iostream>
using namespace std;

// Node structure for Circular Linked List
struct CNode {
    int data;
    CNode* next;
    
    CNode(int val) {
        data = val;
        next = nullptr;
    }
};

// Circular Linked List class
class CircularLinkedList {
private:
    CNode* last;  // Pointer to last node
    
public:
    CircularLinkedList() {
        last = nullptr;
    }
    
    // Insert in empty list
    void insertInEmpty(int val) {
        if (last != nullptr) {
            cout << "List is not empty!\n";
            return;
        }
        
        CNode* newNode = new CNode(val);
        newNode->next = newNode;
        last = newNode;
        cout << val << " inserted in empty list.\n";
    }
    
    // Insert at beginning
    void insertAtBeginning(int val) {
        if (last == nullptr) {
            insertInEmpty(val);
            return;
        }
        
        CNode* newNode = new CNode(val);
        newNode->next = last->next;
        last->next = newNode;
        cout << val << " inserted at beginning.\n";
    }
    
    // Insert at end
    void insertAtEnd(int val) {
        if (last == nullptr) {
            insertInEmpty(val);
            return;
        }
        
        CNode* newNode = new CNode(val);
        newNode->next = last->next;
        last->next = newNode;
        last = newNode;
        cout << val << " inserted at end.\n";
    }
    
    // Insert after specific node
    void insertAfter(int val, int item) {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CNode* newNode = new CNode(val);
        CNode* temp = last->next;
        
        do {
            if (temp->data == item) {
                newNode->next = temp->next;
                temp->next = newNode;
                
                if (temp == last) {
                    last = newNode;
                }
                
                cout << val << " inserted after " << item << ".\n";
                return;
            }
            temp = temp->next;
        } while (temp != last->next);
        
        cout << item << " not found in list.\n";
        delete newNode;
    }
    
    // Delete from beginning
    void deleteFromBeginning() {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CNode* temp = last->next;
        
        if (last->next == last) {  // Only one node
            last = nullptr;
        } else {
            last->next = temp->next;
        }
        
        cout << temp->data << " deleted from beginning.\n";
        delete temp;
    }
    
    // Delete from end
    void deleteFromEnd() {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CNode* temp = last->next;
        CNode* prev = nullptr;
        
        if (last->next == last) {  // Only one node
            cout << last->data << " deleted from end.\n";
            delete last;
            last = nullptr;
            return;
        }
        
        while (temp->next != last->next) {
            prev = temp;
            temp = temp->next;
        }
        
        prev->next = last->next;
        cout << last->data << " deleted from end.\n";
        delete last;
        last = prev;
    }
    
    // Delete specific node
    void deleteNode(int val) {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CNode* temp = last->next;
        CNode* prev = last;
        
        // If list has only one node
        if (last->next == last && last->data == val) {
            cout << val << " deleted from list.\n";
            delete last;
            last = nullptr;
            return;
        }
        
        // If first node to be deleted
        if (temp->data == val) {
            deleteFromBeginning();
            return;
        }
        
        do {
            if (temp->data == val) {
                prev->next = temp->next;
                
                if (temp == last) {
                    last = prev;
                }
                
                cout << val << " deleted from list.\n";
                delete temp;
                return;
            }
            prev = temp;
            temp = temp->next;
        } while (temp != last->next);
        
        cout << val << " not found in list.\n";
    }
    
    // Display list
    void display() {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CNode* temp = last->next;
        cout << "Circular Linked List: ";
        
        do {
            cout << temp->data << " -> ";
            temp = temp->next;
        } while (temp != last->next);
        
        cout << "(back to first)\n";
    }
    
    // Search element
    bool search(int val) {
        if (last == nullptr) {
            cout << "List is empty!\n";
            return false;
        }
        
        CNode* temp = last->next;
        int position = 1;
        
        do {
            if (temp->data == val) {
                cout << val << " found at position " << position << ".\n";
                return true;
            }
            temp = temp->next;
            position++;
        } while (temp != last->next);
        
        cout << val << " not found in list.\n";
        return false;
    }
    
    // Get length
    int length() {
        if (last == nullptr) {
            return 0;
        }
        
        int count = 0;
        CNode* temp = last->next;
        
        do {
            count++;
            temp = temp->next;
        } while (temp != last->next);
        
        return count;
    }
    
    // Destructor
    ~CircularLinkedList() {
        if (last == nullptr) return;
        
        CNode* current = last->next;
        CNode* next;
        
        while (current != last) {
            next = current->next;
            delete current;
            current = next;
        }
        delete last;
    }
};

// Main function to test Circular Linked List
int main() {
    CircularLinkedList cll;
    int choice, value, item;
    
    do {
        cout << "\n===== Circular Linked List Menu =====" << endl;
        cout << "1. Insert in empty list" << endl;
        cout << "2. Insert at beginning" << endl;
        cout << "3. Insert at end" << endl;
        cout << "4. Insert after node" << endl;
        cout << "5. Delete from beginning" << endl;
        cout << "6. Delete from end" << endl;
        cout << "7. Delete specific node" << endl;
        cout << "8. Search element" << endl;
        cout << "9. Display list" << endl;
        cout << "10. Get length" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                cll.insertInEmpty(value);
                break;
                
            case 2:
                cout << "Enter value to insert: ";
                cin >> value;
                cll.insertAtBeginning(value);
                break;
                
            case 3:
                cout << "Enter value to insert: ";
                cin >> value;
                cll.insertAtEnd(value);
                break;
                
            case 4:
                cout << "Enter value to insert: ";
                cin >> value;
                cout << "Enter value after which to insert: ";
                cin >> item;
                cll.insertAfter(value, item);
                break;
                
            case 5:
                cll.deleteFromBeginning();
                break;
                
            case 6:
                cll.deleteFromEnd();
                break;
                
            case 7:
                cout << "Enter value to delete: ";
                cin >> value;
                cll.deleteNode(value);
                break;
                
            case 8:
                cout << "Enter value to search: ";
                cin >> value;
                cll.search(value);
                break;
                
            case 9:
                cll.display();
                break;
                
            case 10:
                cout << "Length of list: " << cll.length() << endl;
                break;
                
            case 0:
                cout << "Exiting program.\n";
                break;
                
            default:
                cout << "Invalid choice!\n";
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>4. Circular Doubly Linked List</h3>
            <button class="copy-btn" onclick="copyCode('code4')">Copy Code</button>
            <pre id="code4">#include <iostream>
using namespace std;

// Node structure for Circular Doubly Linked List
struct CDNode {
    int data;
    CDNode* prev;
    CDNode* next;
    
    CDNode(int val) {
        data = val;
        prev = nullptr;
        next = nullptr;
    }
};

// Circular Doubly Linked List class
class CircularDoublyLinkedList {
private:
    CDNode* head;
    
public:
    CircularDoublyLinkedList() {
        head = nullptr;
    }
    
    // Create node
    CDNode* createNode(int val) {
        CDNode* newNode = new CDNode(val);
        newNode->prev = newNode;
        newNode->next = newNode;
        return newNode;
    }
    
    // Insert in empty list
    void insertInEmpty(int val) {
        if (head != nullptr) {
            cout << "List is not empty!\n";
            return;
        }
        
        head = createNode(val);
        cout << val << " inserted in empty list.\n";
    }
    
    // Insert at beginning
    void insertAtBeginning(int val) {
        if (head == nullptr) {
            insertInEmpty(val);
            return;
        }
        
        CDNode* newNode = createNode(val);
        CDNode* last = head->prev;
        
        newNode->next = head;
        newNode->prev = last;
        
        last->next = newNode;
        head->prev = newNode;
        
        head = newNode;
        cout << val << " inserted at beginning.\n";
    }
    
    // Insert at end
    void insertAtEnd(int val) {
        if (head == nullptr) {
            insertInEmpty(val);
            return;
        }
        
        CDNode* newNode = createNode(val);
        CDNode* last = head->prev;
        
        last->next = newNode;
        newNode->prev = last;
        newNode->next = head;
        head->prev = newNode;
        
        cout << val << " inserted at end.\n";
    }
    
    // Insert after specific node
    void insertAfter(int val, int item) {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CDNode* newNode = createNode(val);
        CDNode* temp = head;
        
        do {
            if (temp->data == item) {
                CDNode* nextNode = temp->next;
                
                temp->next = newNode;
                newNode->prev = temp;
                newNode->next = nextNode;
                nextNode->prev = newNode;
                
                cout << val << " inserted after " << item << ".\n";
                return;
            }
            temp = temp->next;
        } while (temp != head);
        
        cout << item << " not found in list.\n";
        delete newNode;
    }
    
    // Delete from beginning
    void deleteFromBeginning() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        if (head->next == head) {  // Only one node
            cout << head->data << " deleted from beginning.\n";
            delete head;
            head = nullptr;
            return;
        }
        
        CDNode* last = head->prev;
        CDNode* temp = head;
        
        head = head->next;
        head->prev = last;
        last->next = head;
        
        cout << temp->data << " deleted from beginning.\n";
        delete temp;
    }
    
    // Delete from end
    void deleteFromEnd() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        if (head->next == head) {  // Only one node
            deleteFromBeginning();
            return;
        }
        
        CDNode* last = head->prev;
        CDNode* secondLast = last->prev;
        
        secondLast->next = head;
        head->prev = secondLast;
        
        cout << last->data << " deleted from end.\n";
        delete last;
    }
    
    // Delete specific node
    void deleteNode(int val) {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CDNode* current = head;
        CDNode* toDelete = nullptr;
        
        // Find node to delete
        do {
            if (current->data == val) {
                toDelete = current;
                break;
            }
            current = current->next;
        } while (current != head);
        
        if (toDelete == nullptr) {
            cout << val << " not found in list.\n";
            return;
        }
        
        // If only one node
        if (head->next == head) {
            cout << val << " deleted from list.\n";
            delete head;
            head = nullptr;
            return;
        }
        
        // If deleting head
        if (toDelete == head) {
            deleteFromBeginning();
            return;
        }
        
        // If deleting last node
        if (toDelete == head->prev) {
            deleteFromEnd();
            return;
        }
        
        // Delete middle node
        CDNode* prevNode = toDelete->prev;
        CDNode* nextNode = toDelete->next;
        
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
        
        cout << val << " deleted from list.\n";
        delete toDelete;
    }
    
    // Display forward
    void displayForward() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CDNode* temp = head;
        cout << "Circular Doubly Linked List (Forward): ";
        
        do {
            cout << temp->data << " <-> ";
            temp = temp->next;
        } while (temp != head);
        
        cout << "(back to first)\n";
    }
    
    // Display backward
    void displayBackward() {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return;
        }
        
        CDNode* temp = head->prev;
        cout << "Circular Doubly Linked List (Backward): ";
        
        do {
            cout << temp->data << " <-> ";
            temp = temp->prev;
        } while (temp != head->prev);
        
        cout << "(back to last)\n";
    }
    
    // Search element
    bool search(int val) {
        if (head == nullptr) {
            cout << "List is empty!\n";
            return false;
        }
        
        CDNode* temp = head;
        int position = 1;
        
        do {
            if (temp->data == val) {
                cout << val << " found at position " << position << ".\n";
                return true;
            }
            temp = temp->next;
            position++;
        } while (temp != head);
        
        cout << val << " not found in list.\n";
        return false;
    }
    
    // Get length
    int length() {
        if (head == nullptr) {
            return 0;
        }
        
        int count = 0;
        CDNode* temp = head;
        
        do {
            count++;
            temp = temp->next;
        } while (temp != head);
        
        return count;
    }
    
    // Destructor
    ~CircularDoublyLinkedList() {
        if (head == nullptr) return;
        
        CDNode* current = head;
        CDNode* next;
        
        do {
            next = current->next;
            delete current;
            current = next;
        } while (current != head);
    }
};

// Main function to test Circular Doubly Linked List
int main() {
    CircularDoublyLinkedList cdll;
    int choice, value, item;
    
    do {
        cout << "\n===== Circular Doubly Linked List Menu =====" << endl;
        cout << "1. Insert in empty list" << endl;
        cout << "2. Insert at beginning" << endl;
        cout << "3. Insert at end" << endl;
        cout << "4. Insert after node" << endl;
        cout << "5. Delete from beginning" << endl;
        cout << "6. Delete from end" << endl;
        cout << "7. Delete specific node" << endl;
        cout << "8. Search element" << endl;
        cout << "9. Display forward" << endl;
        cout << "10. Display backward" << endl;
        cout << "11. Get length" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                cdll.insertInEmpty(value);
                break;
                
            case 2:
                cout << "Enter value to insert: ";
                cin >> value;
                cdll.insertAtBeginning(value);
                break;
                
            case 3:
                cout << "Enter value to insert: ";
                cin >> value;
                cdll.insertAtEnd(value);
                break;
                
            case 4:
                cout << "Enter value to insert: ";
                cin >> value;
                cout << "Enter value after which to insert: ";
                cin >> item;
                cdll.insertAfter(value, item);
                break;
                
            case 5:
                cdll.deleteFromBeginning();
                break;
                
            case 6:
                cdll.deleteFromEnd();
                break;
                
            case 7:
                cout << "Enter value to delete: ";
                cin >> value;
                cdll.deleteNode(value);
                break;
                
            case 8:
                cout << "Enter value to search: ";
                cin >> value;
                cdll.search(value);
                break;
                
            case 9:
                cdll.displayForward();
                break;
                
            case 10:
                cdll.displayBackward();
                break;
                
            case 11:
                cout << "Length of list: " << cdll.length() << endl;
                break;
                
            case 0:
                cout << "Exiting program.\n";
                break;
                
            default:
                cout << "Invalid choice!\n";
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>
    </div>

    <!-- Stacks Content -->
    <div id="stacks" class="content">
        <h2>Stack Implementation in C++</h2>

        <div class="question">
            <h3>1. Stack Implementation (Array-based)</h3>
            <button class="copy-btn" onclick="copyCode('code5')">Copy Code</button>
            <pre id="code5">#include <iostream>
#define MAX 100  // Maximum size of stack
using namespace std;

class Stack {
private:
    int arr[MAX];
    int top;
    
public:
    Stack() {
        top = -1;  // Initialize stack as empty
    }
    
    // Push operation
    void push(int val) {
        if (isFull()) {
            cout << "Stack Overflow! Cannot push " << val << endl;
            return;
        }
        arr[++top] = val;
        cout << val << " pushed onto stack.\n";
    }
    
    // Pop operation
    int pop() {
        if (isEmpty()) {
            cout << "Stack Underflow! Cannot pop from empty stack.\n";
            return -1;
        }
        int val = arr[top--];
        cout << val << " popped from stack.\n";
        return val;
    }
    
    // Peek operation (view top element)
    int peek() {
        if (isEmpty()) {
            cout << "Stack is empty!\n";
            return -1;
        }
        return arr[top];
    }
    
    // Check if stack is empty
    bool isEmpty() {
        return top == -1;
    }
    
    // Check if stack is full
    bool isFull() {
        return top == MAX - 1;
    }
    
    // Display stack elements
    void display() {
        if (isEmpty()) {
            cout << "Stack is empty!\n";
            return;
        }
        
        cout << "Stack elements (top to bottom): ";
        for (int i = top; i >= 0; i--) {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
    
    // Get stack size
    int size() {
        return top + 1;
    }
};

// Main function to test Stack
int main() {
    Stack s;
    int choice, value;
    
    do {
        cout << "\n===== Stack Operations Menu =====" << endl;
        cout << "1. Push" << endl;
        cout << "2. Pop" << endl;
        cout << "3. Peek" << endl;
        cout << "4. Check if empty" << endl;
        cout << "5. Check if full" << endl;
        cout << "6. Display stack" << endl;
        cout << "7. Get size" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to push: ";
                cin >> value;
                s.push(value);
                break;
                
            case 2:
                s.pop();
                break;
                
            case 3:
                value = s.peek();
                if (value != -1) {
                    cout << "Top element is: " << value << endl;
                }
                break;
                
            case 4:
                if (s.isEmpty()) {
                    cout << "Stack is empty.\n";
                } else {
                    cout << "Stack is not empty.\n";
                }
                break;
                
            case 5:
                if (s.isFull()) {
                    cout << "Stack is full.\n";
                } else {
                    cout << "Stack is not full.\n";
                }
                break;
                
            case 6:
                s.display();
                break;
                
            case 7:
                cout << "Stack size: " << s.size() << endl;
                break;
                
            case 0:
                cout << "Exiting program.\n";
                break;
                
            default:
                cout << "Invalid choice!\n";
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>2. Stack Operations and Types</h3>
            <button class="copy-btn" onclick="copyCode('code6')">Copy Code</button>
            <pre id="code6">#include <iostream>
#include <string>
using namespace std;

// Stack implementation with detailed operations
class DetailedStack {
private:
    int* arr;
    int capacity;
    int top;
    
public:
    DetailedStack(int size) {
        capacity = size;
        arr = new int[capacity];
        top = -1;
        cout << "Stack created with capacity " << capacity << endl;
    }
    
    ~DetailedStack() {
        delete[] arr;
    }
    
    // Operation 1: PUSH
    void push(int val) {
        cout << "\n--- PUSH Operation ---" << endl;
        cout << "Trying to push " << val << " onto stack..." << endl;
        
        if (isFull()) {
            cout << "✗ PUSH FAILED: Stack Overflow!" << endl;
            cout << "Stack is full (capacity: " << capacity << ")" << endl;
            return;
        }
        
        arr[++top] = val;
        cout << "✓ PUSH SUCCESSFUL: " << val << " pushed onto stack" << endl;
        cout << "New top index: " << top << endl;
    }
    
    // Operation 2: POP
    int pop() {
        cout << "\n--- POP Operation ---" << endl;
        cout << "Trying to pop from stack..." << endl;
        
        if (isEmpty()) {
            cout << "✗ POP FAILED: Stack Underflow!" << endl;
            cout << "Stack is empty" << endl;
            return -1;
        }
        
        int val = arr[top--];
        cout << "✓ POP SUCCESSFUL: " << val << " popped from stack" << endl;
        cout << "New top index: " << top << endl;
        return val;
    }
    
    // Operation 3: IS EMPTY
    bool isEmpty() {
        return top == -1;
    }
    
    void checkEmpty() {
        cout << "\n--- IS EMPTY Operation ---" << endl;
        if (isEmpty()) {
            cout << "✓ Stack is EMPTY" << endl;
        } else {
            cout << "✗ Stack is NOT EMPTY" << endl;
            cout << "Current size: " << (top + 1) << endl;
        }
    }
    
    // Operation 4: IS FULL
    bool isFull() {
        return top == capacity - 1;
    }
    
    void checkFull() {
        cout << "\n--- IS FULL Operation ---" << endl;
        if (isFull()) {
            cout << "✓ Stack is FULL" << endl;
            cout << "Capacity: " << capacity << endl;
        } else {
            cout << "✗ Stack is NOT FULL" << endl;
            cout << "Available space: " << (capacity - top - 1) << " elements" << endl;
        }
    }
    
    // Additional operations
    
    // PEEK - View top element
    void peek() {
        cout << "\n--- PEEK Operation ---" << endl;
        if (isEmpty()) {
            cout << "Stack is empty! Nothing to peek." << endl;
        } else {
            cout << "Top element is: " << arr[top] << endl;
            cout << "At index: " << top << endl;
        }
    }
    
    // SIZE - Get current size
    void getSize() {
        cout << "\n--- SIZE Operation ---" << endl;
        cout << "Current stack size: " << (top + 1) << " elements" << endl;
        cout << "Stack capacity: " << capacity << " elements" << endl;
        cout << "Available space: " << (capacity - top - 1) << " elements" << endl;
    }
    
    // DISPLAY - Show all elements
    void display() {
        cout << "\n--- DISPLAY Stack ---" << endl;
        if (isEmpty()) {
            cout << "Stack is empty!" << endl;
            return;
        }
        
        cout << "Stack contents (Top → Bottom):" << endl;
        cout << "┌──────────────┐" << endl;
        for (int i = top; i >= 0; i--) {
            if (i == top) {
                cout << "│ " << arr[i] << " ← TOP   │" << endl;
            } else {
                cout << "│ " << arr[i] << "         │" << endl;
            }
        }
        cout << "└──────────────┘" << endl;
    }
    
    // CLEAR - Empty the stack
    void clear() {
        cout << "\n--- CLEAR Operation ---" << endl;
        if (isEmpty()) {
            cout << "Stack is already empty!" << endl;
        } else {
            top = -1;
            cout << "✓ Stack cleared successfully!" << endl;
        }
    }
};

// Main function to demonstrate stack operations
int main() {
    int size;
    cout << "Enter stack capacity: ";
    cin >> size;
    
    DetailedStack stack(size);
    int choice, value;
    
    do {
        cout << "\n===== DETAILED STACK OPERATIONS =====" << endl;
        cout << "1. PUSH (Add element)" << endl;
        cout << "2. POP (Remove element)" << endl;
        cout << "3. IS EMPTY (Check if empty)" << endl;
        cout << "4. IS FULL (Check if full)" << endl;
        cout << "5. PEEK (View top element)" << endl;
        cout << "6. SIZE (Get current size)" << endl;
        cout << "7. DISPLAY (Show all elements)" << endl;
        cout << "8. CLEAR (Empty the stack)" << endl;
        cout << "0. EXIT" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to push: ";
                cin >> value;
                stack.push(value);
                break;
                
            case 2:
                stack.pop();
                break;
                
            case 3:
                stack.checkEmpty();
                break;
                
            case 4:
                stack.checkFull();
                break;
                
            case 5:
                stack.peek();
                break;
                
            case 6:
                stack.getSize();
                break;
                
            case 7:
                stack.display();
                break;
                
            case 8:
                stack.clear();
                break;
                
            case 0:
                cout << "Exiting program. Thank you!" << endl;
                break;
                
            default:
                cout << "Invalid choice! Please try again." << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>3. Multiple Stack Implementation</h3>
            <button class="copy-btn" onclick="copyCode('code7')">Copy Code</button>
            <pre id="code7">#include <iostream>
#define MAX_SIZE 100
using namespace std;

class MultipleStacks {
private:
    int arr[MAX_SIZE];      // Single array to hold multiple stacks
    int top1, top2;         // Top pointers for two stacks
    int size;               // Total size of array
    
public:
    MultipleStacks(int n) {
        size = n;
        top1 = -1;          // Stack 1 grows from left to right
        top2 = size;        // Stack 2 grows from right to left
        cout << "Multiple stacks created with total capacity: " << n << endl;
        cout << "Stack 1 capacity: " << n/2 << " (approximate)" << endl;
        cout << "Stack 2 capacity: " << n/2 << " (approximate)" << endl;
    }
    
    // ===== STACK 1 OPERATIONS =====
    
    // Push to Stack 1
    void push1(int val) {
        if (top1 + 1 == top2) {
            cout << "Stack 1 Overflow! Cannot push " << val << endl;
            return;
        }
        arr[++top1] = val;
        cout << val << " pushed to Stack 1" << endl;
    }
    
    // Pop from Stack 1
    int pop1() {
        if (top1 == -1) {
            cout << "Stack 1 Underflow! Stack 1 is empty" << endl;
            return -1;
        }
        int val = arr[top1--];
        cout << val << " popped from Stack 1" << endl;
        return val;
    }
    
    // Peek Stack 1
    int peek1() {
        if (top1 == -1) {
            cout << "Stack 1 is empty!" << endl;
            return -1;
        }
        return arr[top1];
    }
    
    // Check if Stack 1 is empty
    bool isEmpty1() {
        return top1 == -1;
    }
    
    // Check if Stack 1 is full
    bool isFull1() {
        return top1 + 1 == top2;
    }
    
    // Get Stack 1 size
    int size1() {
        return top1 + 1;
    }
    
    // ===== STACK 2 OPERATIONS =====
    
    // Push to Stack 2
    void push2(int val) {
        if (top2 - 1 == top1) {
            cout << "Stack 2 Overflow! Cannot push " << val << endl;
            return;
        }
        arr[--top2] = val;
        cout << val << " pushed to Stack 2" << endl;
    }
    
    // Pop from Stack 2
    int pop2() {
        if (top2 == size) {
            cout << "Stack 2 Underflow! Stack 2 is empty" << endl;
            return -1;
        }
        int val = arr[top2++];
        cout << val << " popped from Stack 2" << endl;
        return val;
    }
    
    // Peek Stack 2
    int peek2() {
        if (top2 == size) {
            cout << "Stack 2 is empty!" << endl;
            return -1;
        }
        return arr[top2];
    }
    
    // Check if Stack 2 is empty
    bool isEmpty2() {
        return top2 == size;
    }
    
    // Check if Stack 2 is full
    bool isFull2() {
        return top2 - 1 == top1;
    }
    
    // Get Stack 2 size
    int size2() {
        return size - top2;
    }
    
    // ===== DISPLAY OPERATIONS =====
    
    // Display both stacks
    void display() {
        cout << "\n=== MULTIPLE STACKS STATUS ===" << endl;
        
        // Display Stack 1
        cout << "\nSTACK 1 (Left to Right):" << endl;
        if (isEmpty1()) {
            cout << "  [Empty]" << endl;
        } else {
            cout << "  Top → ";
            for (int i = top1; i >= 0; i--) {
                cout << arr[i] << " ";
            }
            cout << "← Bottom" << endl;
            cout << "  Size: " << size1() << " elements" << endl;
        }
        
        // Display Stack 2
        cout << "\nSTACK 2 (Right to Left):" << endl;
        if (isEmpty2()) {
            cout << "  [Empty]" << endl;
        } else {
            cout << "  Top → ";
            for (int i = top2; i < size; i++) {
                cout << arr[i] << " ";
            }
            cout << "← Bottom" << endl;
            cout << "  Size: " << size2() << " elements" << endl;
        }
        
        // Display array visualization
        cout << "\nArray Visualization:" << endl;
        cout << "Index:    ";
        for (int i = 0; i < size; i++) {
            cout << i << "  ";
        }
        cout << "\nContents: ";
        for (int i = 0; i < size; i++) {
            if (i <= top1) {
                cout << "S1 ";  // Stack 1 element
            } else if (i >= top2) {
                cout << "S2 ";  // Stack 2 element
            } else {
                cout << " . ";  // Empty space
            }
        }
        cout << endl;
        
        cout << "Free space between stacks: " << (top2 - top1 - 1) << " cells" << endl;
    }
    
    // Display individual stack
    void displayStack(int stackNum) {
        if (stackNum == 1) {
            cout << "\n=== STACK 1 DETAILS ===" << endl;
            cout << "Top index: " << top1 << endl;
            cout << "Elements (top to bottom): ";
            if (isEmpty1()) {
                cout << "[Empty]";
            } else {
                for (int i = top1; i >= 0; i--) {
                    cout << arr[i] << " ";
                }
            }
            cout << "\nSize: " << size1() << " elements" << endl;
            cout << "Status: ";
            if (isEmpty1()) cout << "EMPTY";
            else if (isFull1()) cout << "FULL";
            else cout << "PARTIALLY FILLED";
            cout << endl;
        } else if (stackNum == 2) {
            cout << "\n=== STACK 2 DETAILS ===" << endl;
            cout << "Top index: " << top2 << endl;
            cout << "Elements (top to bottom): ";
            if (isEmpty2()) {
                cout << "[Empty]";
            } else {
                for (int i = top2; i < size; i++) {
                    cout << arr[i] << " ";
                }
            }
            cout << "\nSize: " << size2() << " elements" << endl;
            cout << "Status: ";
            if (isEmpty2()) cout << "EMPTY";
            else if (isFull2()) cout << "FULL";
            else cout << "PARTIALLY FILLED";
            cout << endl;
        }
    }
};

// Main function to test Multiple Stacks
int main() {
    int capacity;
    cout << "Enter total capacity for multiple stacks: ";
    cin >> capacity;
    
    MultipleStacks ms(capacity);
    int choice, value, stackNum;
    
    do {
        cout << "\n===== MULTIPLE STACKS MENU =====" << endl;
        cout << "1. Push to Stack 1" << endl;
        cout << "2. Push to Stack 2" << endl;
        cout << "3. Pop from Stack 1" << endl;
        cout << "4. Pop from Stack 2" << endl;
        cout << "5. Peek Stack 1" << endl;
        cout << "6. Peek Stack 2" << endl;
        cout << "7. Check if Stack 1 is empty" << endl;
        cout << "8. Check if Stack 2 is empty" << endl;
        cout << "9. Check if Stack 1 is full" << endl;
        cout << "10. Check if Stack 2 is full" << endl;
        cout << "11. Get Stack 1 size" << endl;
        cout << "12. Get Stack 2 size" << endl;
        cout << "13. Display Stack 1 details" << endl;
        cout << "14. Display Stack 2 details" << endl;
        cout << "15. Display all stacks" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to push to Stack 1: ";
                cin >> value;
                ms.push1(value);
                break;
                
            case 2:
                cout << "Enter value to push to Stack 2: ";
                cin >> value;
                ms.push2(value);
                break;
                
            case 3:
                ms.pop1();
                break;
                
            case 4:
                ms.pop2();
                break;
                
            case 5:
                value = ms.peek1();
                if (value != -1) {
                    cout << "Top of Stack 1: " << value << endl;
                }
                break;
                
            case 6:
                value = ms.peek2();
                if (value != -1) {
                    cout << "Top of Stack 2: " << value << endl;
                }
                break;
                
            case 7:
                if (ms.isEmpty1()) {
                    cout << "Stack 1 is EMPTY" << endl;
                } else {
                    cout << "Stack 1 is NOT EMPTY" << endl;
                }
                break;
                
            case 8:
                if (ms.isEmpty2()) {
                    cout << "Stack 2 is EMPTY" << endl;
                } else {
                    cout << "Stack 2 is NOT EMPTY" << endl;
                }
                break;
                
            case 9:
                if (ms.isFull1()) {
                    cout << "Stack 1 is FULL" << endl;
                } else {
                    cout << "Stack 1 is NOT FULL" << endl;
                }
                break;
                
            case 10:
                if (ms.isFull2()) {
                    cout << "Stack 2 is FULL" << endl;
                } else {
                    cout << "Stack 2 is NOT FULL" << endl;
                }
                break;
                
            case 11:
                cout << "Stack 1 size: " << ms.size1() << " elements" << endl;
                break;
                
            case 12:
                cout << "Stack 2 size: " << ms.size2() << " elements" << endl;
                break;
                
            case 13:
                ms.displayStack(1);
                break;
                
            case 14:
                ms.displayStack(2);
                break;
                
            case 15:
                ms.display();
                break;
                
            case 0:
                cout << "Exiting program." << endl;
                break;
                
            default:
                cout << "Invalid choice!" << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>
    </div>

    <!-- Queues Content -->
    <div id="queues" class="content">
        <h2>Queue Implementation in C++</h2>

        <div class="question">
            <h3>4. Queue Implementation (Array-based)</h3>
            <button class="copy-btn" onclick="copyCode('code8')">Copy Code</button>
            <pre id="code8">#include <iostream>
#define MAX 100
using namespace std;

class Queue {
private:
    int arr[MAX];
    int front, rear;
    
public:
    Queue() {
        front = -1;
        rear = -1;
    }
    
    // Check if queue is empty
    bool isEmpty() {
        return front == -1;
    }
    
    // Check if queue is full
    bool isFull() {
        return (rear + 1) % MAX == front;
    }
    
    // Enqueue operation (add to rear)
    void enqueue(int val) {
        if (isFull()) {
            cout << "Queue Overflow! Cannot enqueue " << val << endl;
            return;
        }
        
        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX;
        }
        
        arr[rear] = val;
        cout << val << " enqueued to queue." << endl;
    }
    
    // Dequeue operation (remove from front)
    int dequeue() {
        if (isEmpty()) {
            cout << "Queue Underflow! Cannot dequeue from empty queue." << endl;
            return -1;
        }
        
        int val = arr[front];
        
        if (front == rear) {
            // Queue becomes empty
            front = rear = -1;
        } else {
            front = (front + 1) % MAX;
        }
        
        cout << val << " dequeued from queue." << endl;
        return val;
    }
    
    // Peek front element
    int peekFront() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        return arr[front];
    }
    
    // Peek rear element
    int peekRear() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        return arr[rear];
    }
    
    // Get queue size
    int size() {
        if (isEmpty()) {
            return 0;
        }
        
        if (rear >= front) {
            return rear - front + 1;
        } else {
            return (MAX - front) + (rear + 1);
        }
    }
    
    // Display queue elements
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return;
        }
        
        cout << "Queue elements (front to rear): ";
        if (rear >= front) {
            for (int i = front; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        } else {
            for (int i = front; i < MAX; i++) {
                cout << arr[i] << " ";
            }
            for (int i = 0; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        }
        cout << endl;
        
        // Show queue structure
        cout << "Front index: " << front << ", Rear index: " << rear << endl;
        cout << "Queue size: " << size() << " elements" << endl;
    }
    
    // Clear queue
    void clear() {
        front = rear = -1;
        cout << "Queue cleared." << endl;
    }
};

// Main function to test Queue
int main() {
    Queue q;
    int choice, value;
    
    do {
        cout << "\n===== QUEUE OPERATIONS MENU =====" << endl;
        cout << "1. Enqueue (Add to rear)" << endl;
        cout << "2. Dequeue (Remove from front)" << endl;
        cout << "3. Peek Front" << endl;
        cout << "4. Peek Rear" << endl;
        cout << "5. Check if empty" << endl;
        cout << "6. Check if full" << endl;
        cout << "7. Get size" << endl;
        cout << "8. Display queue" << endl;
        cout << "9. Clear queue" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                q.enqueue(value);
                break;
                
            case 2:
                q.dequeue();
                break;
                
            case 3:
                value = q.peekFront();
                if (value != -1) {
                    cout << "Front element: " << value << endl;
                }
                break;
                
            case 4:
                value = q.peekRear();
                if (value != -1) {
                    cout << "Rear element: " << value << endl;
                }
                break;
                
            case 5:
                if (q.isEmpty()) {
                    cout << "Queue is EMPTY" << endl;
                } else {
                    cout << "Queue is NOT EMPTY" << endl;
                }
                break;
                
            case 6:
                if (q.isFull()) {
                    cout << "Queue is FULL" << endl;
                } else {
                    cout << "Queue is NOT FULL" << endl;
                }
                break;
                
            case 7:
                cout << "Queue size: " << q.size() << " elements" << endl;
                break;
                
            case 8:
                q.display();
                break;
                
            case 9:
                q.clear();
                break;
                
            case 0:
                cout << "Exiting program." << endl;
                break;
                
            default:
                cout << "Invalid choice!" << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>5. Queue Operations and Types</h3>
            <button class="copy-btn" onclick="copyCode('code9')">Copy Code</button>
            <pre id="code9">#include <iostream>
#define MAX 100
using namespace std;

class DetailedQueue {
private:
    int arr[MAX];
    int front, rear;
    int capacity;
    
public:
    DetailedQueue(int size) {
        capacity = size;
        front = -1;
        rear = -1;
        cout << "Queue created with capacity " << capacity << endl;
    }
    
    // ===== OPERATION 1: ENQUEUE =====
    void enqueue(int val) {
        cout << "\n=== ENQUEUE OPERATION ===" << endl;
        cout << "Trying to enqueue " << val << "..." << endl;
        
        if (isFull()) {
            cout << "✗ ENQUEUE FAILED: Queue Overflow!" << endl;
            cout << "Queue is full (capacity: " << capacity << ")" << endl;
            return;
        }
        
        if (isEmpty()) {
            front = rear = 0;
            cout << "Queue was empty. Setting front and rear to 0." << endl;
        } else {
            rear = (rear + 1) % capacity;
            cout << "Rear moved to index: " << rear << endl;
        }
        
        arr[rear] = val;
        cout << "✓ ENQUEUE SUCCESSFUL: " << val << " added to queue" << endl;
        cout << "Front index: " << front << ", Rear index: " << rear << endl;
    }
    
    // ===== OPERATION 2: DEQUEUE =====
    int dequeue() {
        cout << "\n=== DEQUEUE OPERATION ===" << endl;
        cout << "Trying to dequeue..." << endl;
        
        if (isEmpty()) {
            cout << "✗ DEQUEUE FAILED: Queue Underflow!" << endl;
            cout << "Queue is empty" << endl;
            return -1;
        }
        
        int val = arr[front];
        cout << "Element to dequeue: " << val << " (at index " << front << ")" << endl;
        
        if (front == rear) {
            // Queue becomes empty
            front = rear = -1;
            cout << "Queue becomes empty after dequeue." << endl;
        } else {
            front = (front + 1) % capacity;
            cout << "Front moved to index: " << front << endl;
        }
        
        cout << "✓ DEQUEUE SUCCESSFUL: " << val << " removed from queue" << endl;
        return val;
    }
    
    // ===== OTHER QUEUE OPERATIONS =====
    
    // Check if queue is empty
    bool isEmpty() {
        return front == -1;
    }
    
    void checkEmpty() {
        cout << "\n=== IS EMPTY CHECK ===" << endl;
        if (isEmpty()) {
            cout << "✓ Queue is EMPTY" << endl;
        } else {
            cout << "✗ Queue is NOT EMPTY" << endl;
            cout << "Current size: " << size() << " elements" << endl;
        }
    }
    
    // Check if queue is full
    bool isFull() {
        return (rear + 1) % capacity == front;
    }
    
    void checkFull() {
        cout << "\n=== IS FULL CHECK ===" << endl;
        if (isFull()) {
            cout << "✓ Queue is FULL" << endl;
            cout << "Capacity: " << capacity << " elements" << endl;
        } else {
            cout << "✗ Queue is NOT FULL" << endl;
            cout << "Available space: " << (capacity - size()) << " elements" << endl;
        }
    }
    
    // Get front element
    void getFront() {
        cout << "\n=== GET FRONT OPERATION ===" << endl;
        if (isEmpty()) {
            cout << "Queue is empty! No front element." << endl;
        } else {
            cout << "Front element: " << arr[front] << endl;
            cout << "At index: " << front << endl;
        }
    }
    
    // Get rear element
    void getRear() {
        cout << "\n=== GET REAR OPERATION ===" << endl;
        if (isEmpty()) {
            cout << "Queue is empty! No rear element." << endl;
        } else {
            cout << "Rear element: " << arr[rear] << endl;
            cout << "At index: " << rear << endl;
        }
    }
    
    // Get queue size
    int size() {
        if (isEmpty()) {
            return 0;
        }
        
        if (rear >= front) {
            return rear - front + 1;
        } else {
            return (capacity - front) + (rear + 1);
        }
    }
    
    void getSize() {
        cout << "\n=== GET SIZE OPERATION ===" << endl;
        cout << "Current queue size: " << size() << " elements" << endl;
        cout << "Queue capacity: " << capacity << " elements" << endl;
        cout << "Available space: " << (capacity - size()) << " elements" << endl;
    }
    
    // Display queue
    void display() {
        cout << "\n=== QUEUE DISPLAY ===" << endl;
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return;
        }
        
        // Visual representation
        cout << "Queue visualization:" << endl;
        cout << "Index:    ";
        for (int i = 0; i < capacity; i++) {
            cout << i << "  ";
        }
        cout << "\nContents: ";
        for (int i = 0; i < capacity; i++) {
            if (isEmpty()) {
                cout << " . ";
            } else if ((front <= rear && i >= front && i <= rear) ||
                      (front > rear && (i >= front || i <= rear))) {
                cout << arr[i] << " ";
            } else {
                cout << " . ";
            }
        }
        cout << endl;
        
        // Arrow indicators
        cout << "          ";
        for (int i = 0; i < capacity; i++) {
            if (i == front && i == rear) {
                cout << "F/R";
            } else if (i == front) {
                cout << " F ";
            } else if (i == rear) {
                cout << " R ";
            } else {
                cout << "   ";
            }
        }
        cout << endl;
        
        // Text information
        cout << "\nFront index: " << front << " (Element: " 
             << (isEmpty() ? "None" : to_string(arr[front])) << ")" << endl;
        cout << "Rear index: " << rear << " (Element: " 
             << (isEmpty() ? "None" : to_string(arr[rear])) << ")" << endl;
        
        // Elements in order
        cout << "Elements (front to rear): ";
        if (isEmpty()) {
            cout << "[Empty]";
        } else if (rear >= front) {
            for (int i = front; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        } else {
            for (int i = front; i < capacity; i++) {
                cout << arr[i] << " ";
            }
            for (int i = 0; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        }
        cout << endl;
    }
    
    // Clear queue
    void clear() {
        cout << "\n=== CLEAR QUEUE OPERATION ===" << endl;
        if (isEmpty()) {
            cout << "Queue is already empty!" << endl;
        } else {
            front = rear = -1;
            cout << "✓ Queue cleared successfully!" << endl;
            cout << "All elements removed." << endl;
        }
    }
};

// Main function
int main() {
    int capacity;
    cout << "Enter queue capacity: ";
    cin >> capacity;
    
    DetailedQueue dq(capacity);
    int choice, value;
    
    do {
        cout << "\n===== DETAILED QUEUE OPERATIONS =====" << endl;
        cout << "1. Enqueue (Add to rear)" << endl;
        cout << "2. Dequeue (Remove from front)" << endl;
        cout << "3. Check if empty" << endl;
        cout << "4. Check if full" << endl;
        cout << "5. Get front element" << endl;
        cout << "6. Get rear element" << endl;
        cout << "7. Get size" << endl;
        cout << "8. Display queue" << endl;
        cout << "9. Clear queue" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                dq.enqueue(value);
                break;
                
            case 2:
                dq.dequeue();
                break;
                
            case 3:
                dq.checkEmpty();
                break;
                
            case 4:
                dq.checkFull();
                break;
                
            case 5:
                dq.getFront();
                break;
                
            case 6:
                dq.getRear();
                break;
                
            case 7:
                dq.getSize();
                break;
                
            case 8:
                dq.display();
                break;
                
            case 9:
                dq.clear();
                break;
                
            case 0:
                cout << "Exiting program. Thank you!" << endl;
                break;
                
            default:
                cout << "Invalid choice! Please try again." << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>6. Circular Queue Implementation</h3>
            <button class="copy-btn" onclick="copyCode('code10')">Copy Code</button>
            <pre id="code10">#include <iostream>
using namespace std;

class CircularQueue {
private:
    int* arr;
    int front, rear;
    int capacity;
    int count;  // Track number of elements
    
public:
    CircularQueue(int size) {
        capacity = size;
        arr = new int[capacity];
        front = 0;
        rear = -1;
        count = 0;
        cout << "Circular Queue created with capacity " << capacity << endl;
    }
    
    ~CircularQueue() {
        delete[] arr;
    }
    
    // Check if queue is empty
    bool isEmpty() {
        return count == 0;
    }
    
    // Check if queue is full
    bool isFull() {
        return count == capacity;
    }
    
    // Enqueue operation
    void enqueue(int val) {
        cout << "\n=== ENQUEUE OPERATION ===" << endl;
        
        if (isFull()) {
            cout << "✗ Queue Overflow! Cannot enqueue " << val << endl;
            cout << "Queue is full (capacity: " << capacity << ")" << endl;
            return;
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = val;
        count++;
        
        cout << "✓ " << val << " enqueued successfully" << endl;
        cout << "Rear moved to index: " << rear << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
    }
    
    // Dequeue operation
    int dequeue() {
        cout << "\n=== DEQUEUE OPERATION ===" << endl;
        
        if (isEmpty()) {
            cout << "✗ Queue Underflow! Cannot dequeue from empty queue." << endl;
            return -1;
        }
        
        int val = arr[front];
        cout << "Dequeuing element at index " << front << ": " << val << endl;
        
        front = (front + 1) % capacity;
        count--;
        
        cout << "✓ " << val << " dequeued successfully" << endl;
        cout << "Front moved to index: " << front << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
        
        return val;
    }
    
    // Get front element
    int getFront() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        return arr[front];
    }
    
    // Get rear element
    int getRear() {
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return -1;
        }
        return arr[rear];
    }
    
    // Get queue size
    int getSize() {
        return count;
    }
    
    // Display circular queue
    void display() {
        cout << "\n=== CIRCULAR QUEUE STATUS ===" << endl;
        
        if (isEmpty()) {
            cout << "Queue is empty!" << endl;
            return;
        }
        
        // Visual representation
        cout << "Circular Array Visualization:" << endl;
        cout << "Index:    ";
        for (int i = 0; i < capacity; i++) {
            cout << i << "  ";
        }
        cout << "\nContents: ";
        for (int i = 0; i < capacity; i++) {
            if (count == 0) {
                cout << " . ";
            } else if ((front <= rear && i >= front && i <= rear) ||
                      (front > rear && (i >= front || i <= rear))) {
                cout << arr[i] << " ";
            } else {
                cout << " . ";
            }
        }
        cout << endl;
        
        // Pointer indicators
        cout << "Pointers: ";
        for (int i = 0; i < capacity; i++) {
            if (i == front && i == rear) {
                cout << "F/R";
            } else if (i == front) {
                cout << " F ";
            } else if (i == rear) {
                cout << " R ";
            } else {
                cout << "   ";
            }
        }
        cout << endl;
        
        // Queue information
        cout << "\nQueue Information:" << endl;
        cout << "Front: index " << front << " (value: " << arr[front] << ")" << endl;
        cout << "Rear:  index " << rear << " (value: " << arr[rear] << ")" << endl;
        cout << "Size:  " << count << "/" << capacity << " elements" << endl;
        cout << "Empty slots: " << (capacity - count) << endl;
        
        // Circular traversal
        cout << "\nElements in circular order (front to rear):" << endl;
        cout << "START → ";
        
        if (front <= rear) {
            // Normal case
            for (int i = front; i <= rear; i++) {
                cout << arr[i] << " → ";
            }
        } else {
            // Wrapped around case
            for (int i = front; i < capacity; i++) {
                cout << arr[i] << " → ";
            }
            for (int i = 0; i <= rear; i++) {
                cout << arr[i] << " → ";
            }
        }
        cout << "BACK TO FRONT (Circular)" << endl;
        
        // Memory layout
        cout << "\nMemory Layout:" << endl;
        cout << "┌";
        for (int i = 0; i < capacity; i++) {
            cout << "───";
            if (i < capacity - 1) cout << "┬";
        }
        cout << "┐" << endl;
        
        cout << "│";
        for (int i = 0; i < capacity; i++) {
            if (isEmpty()) {
                cout << "   ";
            } else if ((front <= rear && i >= front && i <= rear) ||
                      (front > rear && (i >= front || i <= rear))) {
                printf("%2d ", arr[i]);
            } else {
                cout << "   ";
            }
            cout << "│";
        }
        cout << endl;
        
        cout << "└";
        for (int i = 0; i < capacity; i++) {
            cout << "───";
            if (i < capacity - 1) cout << "┴";
        }
        cout << "┘" << endl;
        
        cout << " ";
        for (int i = 0; i < capacity; i++) {
            if (i == front && i == rear) {
                cout << "F/R ";
            } else if (i == front) {
                cout << " F  ";
            } else if (i == rear) {
                cout << " R  ";
            } else {
                cout << "    ";
            }
        }
        cout << endl;
    }
    
    // Clear queue
    void clear() {
        front = 0;
        rear = -1;
        count = 0;
        cout << "✓ Circular Queue cleared successfully!" << endl;
    }
};

// Main function
int main() {
    int capacity;
    cout << "Enter capacity for circular queue: ";
    cin >> capacity;
    
    CircularQueue cq(capacity);
    int choice, value;
    
    do {
        cout << "\n===== CIRCULAR QUEUE MENU =====" << endl;
        cout << "1. Enqueue" << endl;
        cout << "2. Dequeue" << endl;
        cout << "3. Get Front" << endl;
        cout << "4. Get Rear" << endl;
        cout << "5. Check if Empty" << endl;
        cout << "6. Check if Full" << endl;
        cout << "7. Get Size" << endl;
        cout << "8. Display Queue" << endl;
        cout << "9. Clear Queue" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                cq.enqueue(value);
                break;
                
            case 2:
                cq.dequeue();
                break;
                
            case 3:
                value = cq.getFront();
                if (value != -1) {
                    cout << "Front element: " << value << endl;
                }
                break;
                
            case 4:
                value = cq.getRear();
                if (value != -1) {
                    cout << "Rear element: " << value << endl;
                }
                break;
                
            case 5:
                if (cq.isEmpty()) {
                    cout << "Queue is EMPTY" << endl;
                } else {
                    cout << "Queue is NOT EMPTY" << endl;
                }
                break;
                
            case 6:
                if (cq.isFull()) {
                    cout << "Queue is FULL" << endl;
                } else {
                    cout << "Queue is NOT FULL" << endl;
                }
                break;
                
            case 7:
                cout << "Queue size: " << cq.getSize() << " elements" << endl;
                break;
                
            case 8:
                cq.display();
                break;
                
            case 9:
                cq.clear();
                break;
                
            case 0:
                cout << "Exiting program." << endl;
                break;
                
            default:
                cout << "Invalid choice!" << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>

        <div class="question">
            <h3>7. Deque (Double Ended Queue) Implementation</h3>
            <button class="copy-btn" onclick="copyCode('code11')">Copy Code</button>
            <pre id="code11">#include <iostream>
using namespace std;

class Deque {
private:
    int* arr;
    int front, rear;
    int capacity;
    int count;
    
public:
    Deque(int size) {
        capacity = size;
        arr = new int[capacity];
        front = -1;
        rear = 0;
        count = 0;
        cout << "Deque created with capacity " << capacity << endl;
    }
    
    ~Deque() {
        delete[] arr;
    }
    
    // Check if deque is empty
    bool isEmpty() {
        return count == 0;
    }
    
    // Check if deque is full
    bool isFull() {
        return count == capacity;
    }
    
    // Insert at front
    void insertFront(int val) {
        cout << "\n=== INSERT AT FRONT ===" << endl;
        
        if (isFull()) {
            cout << "✗ Deque Overflow! Cannot insert " << val << " at front" << endl;
            return;
        }
        
        // If deque is initially empty
        if (front == -1) {
            front = 0;
            rear = 0;
        }
        // If front is at first position, wrap around
        else if (front == 0) {
            front = capacity - 1;
        }
        // Normal decrement
        else {
            front = front - 1;
        }
        
        arr[front] = val;
        count++;
        
        cout << "✓ " << val << " inserted at front successfully" << endl;
        cout << "New front index: " << front << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
    }
    
    // Insert at rear
    void insertRear(int val) {
        cout << "\n=== INSERT AT REAR ===" << endl;
        
        if (isFull()) {
            cout << "✗ Deque Overflow! Cannot insert " << val << " at rear" << endl;
            return;
        }
        
        // If deque is initially empty
        if (front == -1) {
            front = 0;
            rear = 0;
        }
        // If rear is at last position, wrap around
        else if (rear == capacity - 1) {
            rear = 0;
        }
        // Normal increment
        else {
            rear = rear + 1;
        }
        
        arr[rear] = val;
        count++;
        
        cout << "✓ " << val << " inserted at rear successfully" << endl;
        cout << "New rear index: " << rear << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
    }
    
    // Delete from front
    void deleteFront() {
        cout << "\n=== DELETE FROM FRONT ===" << endl;
        
        if (isEmpty()) {
            cout << "✗ Deque Underflow! Cannot delete from front" << endl;
            return;
        }
        
        cout << "Deleting element at index " << front << ": " << arr[front] << endl;
        
        // If only one element
        if (front == rear) {
            front = -1;
            rear = -1;
        }
        // If front is at last position, wrap around
        else if (front == capacity - 1) {
            front = 0;
        }
        // Normal increment
        else {
            front = front + 1;
        }
        
        count--;
        cout << "✓ Element deleted from front successfully" << endl;
        cout << "New front index: " << front << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
    }
    
    // Delete from rear
    void deleteRear() {
        cout << "\n=== DELETE FROM REAR ===" << endl;
        
        if (isEmpty()) {
            cout << "✗ Deque Underflow! Cannot delete from rear" << endl;
            return;
        }
        
        cout << "Deleting element at index " << rear << ": " << arr[rear] << endl;
        
        // If only one element
        if (front == rear) {
            front = -1;
            rear = -1;
        }
        // If rear is at first position, wrap around
        else if (rear == 0) {
            rear = capacity - 1;
        }
        // Normal decrement
        else {
            rear = rear - 1;
        }
        
        count--;
        cout << "✓ Element deleted from rear successfully" << endl;
        cout << "New rear index: " << rear << endl;
        cout << "Current size: " << count << "/" << capacity << endl;
    }
    
    // Get front element
    int getFront() {
        if (isEmpty()) {
            cout << "Deque is empty!" << endl;
            return -1;
        }
        return arr[front];
    }
    
    // Get rear element
    int getRear() {
        if (isEmpty()) {
            cout << "Deque is empty!" << endl;
            return -1;
        }
        return arr[rear];
    }
    
    // Get size
    int getSize() {
        return count;
    }
    
    // Display deque
    void display() {
        cout << "\n=== DEQUE STATUS ===" << endl;
        
        if (isEmpty()) {
            cout << "Deque is empty!" << endl;
            return;
        }
        
        // Visual representation
        cout << "Deque Visualization (Circular Array):" << endl;
        cout << "Index:    ";
        for (int i = 0; i < capacity; i++) {
            printf("%2d ", i);
        }
        cout << "\nContents: ";
        for (int i = 0; i < capacity; i++) {
            if (isEmpty()) {
                cout << " . ";
            } else if (front <= rear) {
                if (i >= front && i <= rear) {
                    printf("%2d ", arr[i]);
                } else {
                    cout << " . ";
                }
            } else {
                if (i <= rear || i >= front) {
                    printf("%2d ", arr[i]);
                } else {
                    cout << " . ";
                }
            }
        }
        cout << endl;
        
        // Pointer indicators
        cout << "Pointers: ";
        for (int i = 0; i < capacity; i++) {
            if (i == front && i == rear) {
                cout << "F/R";
            } else if (i == front) {
                cout << " F ";
            } else if (i == rear) {
                cout << " R ";
            } else {
                cout << "   ";
            }
        }
        cout << endl;
        
        // Deque information
        cout << "\nDeque Information:" << endl;
        cout << "Front: index " << front << " (value: " << arr[front] << ")" << endl;
        cout << "Rear:  index " << rear << " (value: " << arr[rear] << ")" << endl;
        cout << "Size:  " << count << "/" << capacity << " elements" << endl;
        
        // Operations summary
        cout << "\nAvailable Operations:" << endl;
        cout << "1. Insert at Front (Left end)" << endl;
        cout << "2. Insert at Rear  (Right end)" << endl;
        cout << "3. Delete from Front" << endl;
        cout << "4. Delete from Rear" << endl;
        cout << "5. View Front element" << endl;
        cout << "6. View Rear element" << endl;
        
        // Elements in order
        cout << "\nElements (front to rear): ";
        if (isEmpty()) {
            cout << "[Empty]";
        } else if (front <= rear) {
            for (int i = front; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        } else {
            for (int i = front; i < capacity; i++) {
                cout << arr[i] << " ";
            }
            for (int i = 0; i <= rear; i++) {
                cout << arr[i] << " ";
            }
        }
        cout << endl;
        
        // ASCII art representation
        cout << "\nDeque Structure:" << endl;
        if (!isEmpty()) {
            cout << "   ";
            for (int i = 0; i < count; i++) {
                cout << "┌───┐ ";
            }
            cout << endl << "← ";
            
            if (front <= rear) {
                for (int i = front; i <= rear; i++) {
                    printf("│%2d │ ", arr[i]);
                }
            } else {
                for (int i = front; i < capacity; i++) {
                    printf("│%2d │ ", arr[i]);
                }
                for (int i = 0; i <= rear; i++) {
                    printf("│%2d │ ", arr[i]);
                }
            }
            
            cout << "→" << endl << "   ";
            for (int i = 0; i < count; i++) {
                cout << "└───┘ ";
            }
            cout << endl;
            
            cout << "   ";
            for (int i = 0; i < count; i++) {
                if (i == 0) {
                    cout << "Front ";
                } else if (i == count - 1) {
                    cout << "Rear  ";
                } else {
                    cout << "      ";
                }
            }
            cout << endl;
        }
    }
    
    // Clear deque
    void clear() {
        front = -1;
        rear = 0;
        count = 0;
        cout << "✓ Deque cleared successfully!" << endl;
    }
};

// Main function
int main() {
    int capacity;
    cout << "Enter capacity for deque: ";
    cin >> capacity;
    
    Deque dq(capacity);
    int choice, value;
    
    do {
        cout << "\n===== DEQUE (DOUBLE ENDED QUEUE) MENU =====" << endl;
        cout << "1. Insert at Front" << endl;
        cout << "2. Insert at Rear" << endl;
        cout << "3. Delete from Front" << endl;
        cout << "4. Delete from Rear" << endl;
        cout << "5. Get Front element" << endl;
        cout << "6. Get Rear element" << endl;
        cout << "7. Check if Empty" << endl;
        cout << "8. Check if Full" << endl;
        cout << "9. Get Size" << endl;
        cout << "10. Display Deque" << endl;
        cout << "11. Clear Deque" << endl;
        cout << "0. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to insert at front: ";
                cin >> value;
                dq.insertFront(value);
                break;
                
            case 2:
                cout << "Enter value to insert at rear: ";
                cin >> value;
                dq.insertRear(value);
                break;
                
            case 3:
                dq.deleteFront();
                break;
                
            case 4:
                dq.deleteRear();
                break;
                
            case 5:
                value = dq.getFront();
                if (value != -1) {
                    cout << "Front element: " << value << endl;
                }
                break;
                
            case 6:
                value = dq.getRear();
                if (value != -1) {
                    cout << "Rear element: " << value << endl;
                }
                break;
                
            case 7:
                if (dq.isEmpty()) {
                    cout << "Deque is EMPTY" << endl;
                } else {
                    cout << "Deque is NOT EMPTY" << endl;
                }
                break;
                
            case 8:
                if (dq.isFull()) {
                    cout << "Deque is FULL" << endl;
                } else {
                    cout << "Deque is NOT FULL" << endl;
                }
                break;
                
            case 9:
                cout << "Deque size: " << dq.getSize() << " elements" << endl;
                break;
                
            case 10:
                dq.display();
                break;
                
            case 11:
                dq.clear();
                break;
                
            case 0:
                cout << "Exiting program." << endl;
                break;
                
            default:
                cout << "Invalid choice!" << endl;
        }
    } while(choice != 0);
    
    return 0;
}</pre>
        </div>
    </div>

    <div class="footer">
        <p>Data Structures Implementation in C++ | Complete Code Examples</p>
        <p>Includes: Linked Lists, Stacks, Queues, Circular Queues, and Deques</p>
    </div>

    <script>
        function showTab(tabName) {
            // Hide all tabs
            var tabs = document.querySelectorAll('.content');
            tabs.forEach(function (tab) {
                tab.classList.remove('active');
            });

            // Remove active class from all tab buttons
            var tabButtons = document.querySelectorAll('.tab');
            tabButtons.forEach(function (button) {
                button.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked button
            event.target.classList.add('active');
        }

        function copyCode(elementId) {
            const codeElement = document.getElementById(elementId);
            const text = codeElement.textContent;

            navigator.clipboard.writeText(text).then(() => {
                const originalText = event.target.textContent;
                event.target.textContent = 'Copied!';
                event.target.style.backgroundColor = '#155724';

                setTimeout(() => {
                    event.target.textContent = originalText;
                    event.target.style.backgroundColor = '#28a745';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy code. Please select and copy manually.');
            });
        }
    </script>
</body>

</html>